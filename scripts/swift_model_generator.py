#!/usr/bin/env python3
"""
Swift Model Generator from Pydantic Schema

This script generates Swift model files from parsed Pydantic schema metadata,
ensuring proper protocol conformance and type safety for the Utah News Platform.

Usage:
    python swift_model_generator.py --schema-file <path-to-schema.json> --output-dir <path-to-swift-output>
"""

import json
import argparse
from pathlib import Path
from typing import Dict, List, Set, Optional
from datetime import datetime


class SwiftModelGenerator:
    """Generates Swift models from Pydantic schema metadata"""
    
    def __init__(self, output_dir: str):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Standard protocols for generated models
        self.standard_protocols = ['Codable', 'Identifiable', 'Hashable', 'JSONSchemaProvider', 'Sendable']
        
        # Import requirements for different types
        self.import_requirements = {
            'Date': 'Foundation',
            'Data': 'Foundation',
            'UUID': 'Foundation',
        }
    
    def generate_from_schema(self, schema_file: str):
        """Generate Swift models from a schema JSON file"""
        with open(schema_file, 'r', encoding='utf-8') as f:
            schema_data = json.load(f)
        
        models = schema_data.get('models', [])
        
        for model_data in models:
            self._generate_model_file(model_data)
        
        # Generate a combined index file
        self._generate_index_file(models)
        
        print(f"Generated {len(models)} Swift model files in {self.output_dir}")
    
    def _generate_model_file(self, model_data: dict):
        """Generate a single Swift model file"""
        model_name = model_data['name']
        file_path = self.output_dir / f"{model_name}.swift"
        
        swift_content = self._generate_swift_content(model_data)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(swift_content)
        
        print(f"Generated: {file_path}")
    
    def _generate_swift_content(self, model_data: dict) -> str:
        """Generate the complete Swift file content for a model"""
        model_name = model_data['name']
        
        # Collect required imports
        imports = self._collect_imports(model_data)
        
        # Generate file header
        header = self._generate_file_header(model_name, model_data.get('docstring'))
        
        # Generate imports
        imports_section = self._generate_imports(imports)
        
        # Generate model code
        if model_data.get('is_enum', False):
            model_code = self._generate_enum(model_data)
        else:
            model_code = self._generate_struct(model_data)
        
        return f"{header}\n\n{imports_section}\n\n{model_code}"
    
    def _generate_file_header(self, model_name: str, docstring: Optional[str]) -> str:
        """Generate the Swift file header comment"""
        current_date = datetime.now().strftime("%m/%d/%y")
        
        summary = f"Defines the {model_name} model"
        if docstring:
            # Clean up the docstring for Swift comment format
            summary = docstring.strip().replace('\n', ' ')[:100]
            if len(docstring) > 100:
                summary += "..."
        
        return f"""//
//  {model_name}.swift
//  UtahNewsDataModels (Generated)
//
//  Auto-generated from Python Pydantic model on {current_date}
//
//  Summary: {summary}
//           This file is automatically generated. Do not edit manually."""
    
    def _generate_imports(self, imports: Set[str]) -> str:
        """Generate the imports section"""
        if not imports:
            return ""
        
        # Sort imports with Foundation first
        sorted_imports = sorted(imports, key=lambda x: (x != 'Foundation', x))
        import_lines = [f"import {imp}" for imp in sorted_imports]
        
        return "\n".join(import_lines)
    
    def _collect_imports(self, model_data: dict) -> Set[str]:
        """Collect all required imports for a model"""
        imports = set()
        
        # Always include Foundation for basic types
        imports.add('Foundation')
        
        # Check field types for import requirements
        for field in model_data.get('fields', []):
            swift_type = field['swift_type']
            
            # Remove optionals and array/dictionary wrappers to get base type
            base_type = self._extract_base_type(swift_type)
            
            if base_type in self.import_requirements:
                imports.add(self.import_requirements[base_type])
        
        return imports
    
    def _extract_base_type(self, swift_type: str) -> str:
        """Extract the base type from a complex Swift type"""
        # Remove optional marker
        if swift_type.endswith('?'):
            swift_type = swift_type[:-1]
        
        # Handle arrays
        if swift_type.startswith('[') and swift_type.endswith(']'):
            inner = swift_type[1:-1]
            if ':' in inner:  # Dictionary
                # Get value type
                parts = inner.split(':', 1)
                return parts[1].strip()
            else:  # Array
                return inner
        
        return swift_type
    
    def _generate_enum(self, model_data: dict) -> str:
        """Generate Swift enum code"""
        name = model_data['name']
        enum_values = model_data.get('enum_values', [])
        
        # Generate enum cases
        cases = []
        for value in enum_values:
            # Convert Python enum names to Swift naming conventions
            swift_case = self._to_camel_case(value.lower())
            cases.append(f"    case {swift_case}")
        
        # Generate protocols
        protocols = ['String', 'CaseIterable', 'Codable', 'Sendable']
        protocol_list = ', '.join(protocols)
        
        enum_code = f"""/// {name} enumeration
/// Auto-generated from Python Pydantic model
public enum {name}: {protocol_list} {{
{chr(10).join(cases)}
}}"""
        
        return enum_code
    
    def _generate_struct(self, model_data: dict) -> str:
        """Generate Swift struct code"""
        name = model_data['name']
        fields = model_data.get('fields', [])
        
        # Determine if this model should conform to AssociatedData
        has_relationships = any(field['name'] == 'relationships' for field in fields)
        
        # Build protocol list
        protocols = self.standard_protocols.copy()
        if has_relationships:
            protocols.insert(0, 'AssociatedData')  # Add at the beginning
        
        protocol_list = ', '.join(protocols)
        
        # Generate struct header
        struct_header = f"""/// {name} model
/// Auto-generated from Python Pydantic model
public struct {name}: {protocol_list} {{"""
        
        # Generate properties
        properties = self._generate_properties(fields)
        
        # Generate initializer
        initializer = self._generate_initializer(name, fields)
        
        # Generate JSONSchemaProvider implementation
        json_schema = self._generate_json_schema_implementation(name, fields)
        
        # Combine all parts
        struct_code = f"""{struct_header}
    // MARK: - Properties
{properties}

    // MARK: - Initializer
{initializer}

    // MARK: - JSONSchemaProvider Implementation
{json_schema}
}}"""
        
        return struct_code
    
    def _generate_properties(self, fields: List[dict]) -> str:
        """Generate Swift properties from field metadata"""
        properties = []
        
        for field in fields:
            name = field['name']
            swift_type = field['swift_type']
            description = field.get('description', f"{name} property")
            default_value = field.get('default_value')
            is_optional = field['is_optional']
            
            # Generate property documentation
            property_doc = f"    /// {description}"
            
            # Handle default values
            default_assignment = ""
            if default_value and not is_optional:
                if field['is_list']:
                    default_assignment = " = []"
                elif field['is_dict']:
                    default_assignment = " = [:]"
                elif swift_type == "String" and default_value.startswith('"'):
                    default_assignment = f" = {default_value}"
                elif swift_type in ["Int", "Double", "Bool"]:
                    # Convert Python values to Swift
                    swift_default = self._convert_default_value(default_value, swift_type)
                    if swift_default:
                        default_assignment = f" = {swift_default}"
            
            # Generate property declaration
            property_decl = f"    public var {name}: {swift_type}{default_assignment}"
            
            properties.append(f"{property_doc}\n{property_decl}")
        
        return "\n\n".join(properties)
    
    def _generate_initializer(self, model_name: str, fields: List[dict]) -> str:
        """Generate Swift initializer"""
        # Prepare parameter list
        params = []
        assignments = []
        
        for field in fields:
            name = field['name']
            swift_type = field['swift_type']
            is_optional = field['is_optional']
            default_value = field.get('default_value')
            
            # Generate parameter with default
            param_default = ""
            if name == 'id':
                param_default = " = UUID().uuidString"
            elif field['is_list'] and not is_optional:
                param_default = " = []"
            elif field['is_dict'] and not is_optional:
                param_default = " = [:]"
            elif is_optional:
                param_default = " = nil"
            elif default_value:
                swift_default = self._convert_default_value(default_value, swift_type)
                if swift_default:
                    param_default = f" = {swift_default}"
            
            params.append(f"        {name}: {swift_type}{param_default}")
            assignments.append(f"        self.{name} = {name}")
        
        param_list = ",\n".join(params)
        assignment_list = "\n".join(assignments)
        
        initializer = f"""    /// Creates a new {model_name} instance
    public init(
{param_list}
    ) {{
{assignment_list}
    }}"""
        
        return initializer
    
    def _generate_json_schema_implementation(self, model_name: str, fields: List[dict]) -> str:
        """Generate JSONSchemaProvider implementation"""
        # Generate properties for the JSON schema
        schema_properties = []
        required_fields = []
        
        for field in fields:
            name = field['name']
            swift_type = field['swift_type']
            is_optional = field['is_optional']
            is_list = field['is_list']
            is_dict = field['is_dict']
            description = field.get('description', f"{name} property")
            
            # Map Swift type to JSON Schema type
            json_type = self._swift_type_to_json_schema_type(swift_type, is_list, is_dict)
            
            # Build property schema
            property_schema = f'                "{name}": {json_type}'
            schema_properties.append(property_schema)
            
            # Add to required if not optional
            if not is_optional and name != 'id':  # id is usually optional in input
                required_fields.append(f'"{name}"')
        
        properties_section = ",\n".join(schema_properties)
        required_section = ", ".join(required_fields)
        
        json_schema_impl = f'''    public static var jsonSchema: String {{
        """
        {{
            "type": "object",
            "properties": {{
{properties_section}
            }},
            "required": [{required_section}]
        }}
        """
    }}'''
        
        return json_schema_impl
    
    def _swift_type_to_json_schema_type(self, swift_type: str, is_list: bool, is_dict: bool) -> str:
        """Convert Swift type to JSON Schema type specification"""
        # Remove optional marker
        base_type = swift_type.rstrip('?')
        
        if is_list:
            # Array type
            inner_type = self._extract_array_element_type(base_type)
            inner_json_type = self._basic_swift_to_json_type(inner_type)
            return f'{{"type": "array", "items": {inner_json_type}}}'
        elif is_dict:
            # Dictionary type
            value_type = self._extract_dict_value_type(base_type)
            value_json_type = self._basic_swift_to_json_type(value_type)
            return f'{{"type": "object", "additionalProperties": {value_json_type}}}'
        else:
            return self._basic_swift_to_json_type(base_type)
    
    def _basic_swift_to_json_type(self, swift_type: str) -> str:
        """Convert basic Swift type to JSON Schema type"""
        type_mapping = {
            'String': '{"type": "string"}',
            'Int': '{"type": "integer"}',
            'Double': '{"type": "number"}',
            'Bool': '{"type": "boolean"}',
            'Date': '{"type": "string", "format": "date-time"}',
            'Data': '{"type": "string", "format": "base64"}',
        }
        
        return type_mapping.get(swift_type, '{"type": "string"}')
    
    def _extract_array_element_type(self, array_type: str) -> str:
        """Extract element type from Swift array type like [String]"""
        if array_type.startswith('[') and array_type.endswith(']'):
            return array_type[1:-1]
        return 'String'
    
    def _extract_dict_value_type(self, dict_type: str) -> str:
        """Extract value type from Swift dictionary type like [String: Int]"""
        if dict_type.startswith('[') and dict_type.endswith(']'):
            inner = dict_type[1:-1]
            if ':' in inner:
                parts = inner.split(':', 1)
                return parts[1].strip()
        return 'String'
    
    def _convert_default_value(self, python_default: str, swift_type: str) -> Optional[str]:
        """Convert Python default value to Swift equivalent"""
        if not python_default:
            return None
        
        # Handle common conversions
        if python_default == 'None':
            return 'nil'
        elif python_default == 'True':
            return 'true'
        elif python_default == 'False':
            return 'false'
        elif python_default == '[]':
            return '[]'
        elif python_default == '{}':
            return '[:]'
        elif python_default.startswith('"') and python_default.endswith('"'):
            return python_default  # String literal
        elif python_default.isdigit() or python_default.replace('.', '').isdigit():
            return python_default  # Numeric literal
        
        return None
    
    def _to_camel_case(self, snake_str: str) -> str:
        """Convert snake_case to camelCase"""
        components = snake_str.split('_')
        return components[0] + ''.join(word.capitalize() for word in components[1:])
    
    def _generate_index_file(self, models: List[dict]):
        """Generate an index file that imports all generated models"""
        index_path = self.output_dir / "GeneratedModels.swift"
        
        # Create list of model names
        model_names = [model['name'] for model in models]
        
        # Generate file content
        header = self._generate_file_header("GeneratedModels", "Index file for all generated models")
        
        # Generate re-exports
        exports = []
        for model_name in sorted(model_names):
            exports.append(f"@_exported import struct UtahNewsDataModels.{model_name}")
        
        exports_section = "\n".join(exports)
        
        content = f"""{header}

import Foundation

// MARK: - Generated Model Exports
// This file provides convenient access to all auto-generated models

{exports_section}

// MARK: - Generated Models List
/// List of all auto-generated model names
public let generatedModelNames: [String] = [
{','.join([f'    "{name}"' for name in sorted(model_names)])}
]

/// Total count of generated models
public let generatedModelCount = {len(model_names)}
"""
        
        with open(index_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"Generated index file: {index_path}")


def main():
    parser = argparse.ArgumentParser(description='Generate Swift models from Pydantic schema')
    parser.add_argument('--schema-file', required=True, help='JSON file containing parsed Pydantic schema')
    parser.add_argument('--output-dir', required=True, help='Directory to output Swift model files')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        print(f"Generating Swift models from: {args.schema_file}")
        print(f"Output directory: {args.output_dir}")
    
    # Generate models
    generator = SwiftModelGenerator(args.output_dir)
    generator.generate_from_schema(args.schema_file)
    
    print("Swift model generation complete!")


if __name__ == '__main__':
    main()